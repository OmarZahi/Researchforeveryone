---
// Hero component with Motion One animations
export interface Props {
  title: string;
  subtitle: string;
  primaryCta?: { text: string; href: string };
  secondaryCta?: { text: string; href: string };
  backgroundType?: 'default' | 'about';
}

const { 
  title, 
  subtitle, 
  primaryCta, 
  secondaryCta,
  backgroundType = 'default'
} = Astro.props;

const heroClass = backgroundType === 'about' ? 'hero about-hero' : 'hero';
---

<section class={heroClass} id="home">
  <canvas class="hero-canvas" aria-hidden="true"></canvas>
  <div class="hero-objects">
    <div class="chip chip-a"></div>
    <div class="chip chip-b"></div>
    <div class="chip chip-c"></div>
    <div class="chip chip-d"></div>
  </div>
  <div class="container">
    <h1 id="hero-title">{title}</h1>
    <p id="hero-subtitle">{subtitle}</p>
    {(primaryCta || secondaryCta) && (
      <div class="cta-row" id="hero-cta">
        {primaryCta && (
          <a href={primaryCta.href} class="btn primary">{primaryCta.text}</a>
        )}
        {secondaryCta && (
          <a href={secondaryCta.href} class="btn outline">{secondaryCta.text}</a>
        )}
      </div>
    )}
  </div>
</section>

<script>
import { animate, stagger } from 'motion';

// Lightweight canvas network background (inlined from assets to co-locate with component)
function initializeHeroCanvas() {
  const prefersReduced = window.matchMedia && window.matchMedia('(prefers-reduced-motion: reduce)').matches;
  const canvas = document.querySelector('.hero-canvas') as HTMLCanvasElement | null;
  if (!canvas || prefersReduced) return;

  const ctx = canvas.getContext('2d');
  if (!ctx) return;
  const c = canvas as HTMLCanvasElement;
  const context = ctx as CanvasRenderingContext2D;
  const dpr = Math.min(2, window.devicePixelRatio || 1);
  let nodes: Array<{x:number;y:number;vx:number;vy:number;r:number}> = [];
  const mouse = { x: 0, y: 0, active: false };
  const hue = 215; // blue-ish
  let rafId = 0;

  function resize() {
  const rect = c.getBoundingClientRect();
  c.width = Math.floor(rect.width * dpr);
  c.height = Math.floor(rect.height * dpr);
  context.setTransform(dpr, 0, 0, dpr, 0, 0);
    init();
  }

  function init() {
  const rect = c.getBoundingClientRect();
    const count = Math.max(24, Math.floor((rect.width * rect.height) / 25000));
    nodes = [];
    for (let i = 0; i < count; i++) {
      nodes.push({
        x: Math.random() * rect.width,
        y: Math.random() * rect.height,
        vx: (Math.random() - 0.5) * 0.4,
        vy: (Math.random() - 0.5) * 0.4,
        r: 1.2 + Math.random() * 1.6,
      });
    }
  }

  function draw() {
  const rect = c.getBoundingClientRect();
  context.clearRect(0, 0, rect.width, rect.height);

    // update + connect
    for (let i = 0; i < nodes.length; i++) {
      const a = nodes[i];
      a.x += a.vx; a.y += a.vy;
      if (a.x < -20 || a.x > rect.width + 20) a.vx *= -1;
      if (a.y < -20 || a.y > rect.height + 20) a.vy *= -1;

      if (mouse.active) {
        const dxm = a.x - mouse.x;
        const dym = a.y - mouse.y;
        const dm2 = dxm * dxm + dym * dym;
        if (dm2 < 16000) { a.vx -= dxm * 0.0005; a.vy -= dym * 0.0005; }
      }

      for (let j = i + 1; j < nodes.length; j++) {
        const b = nodes[j];
        const dx = a.x - b.x; const dy = a.y - b.y; const dist2 = dx * dx + dy * dy;
        if (dist2 < 26000) {
          const alpha = 1 - dist2 / 26000;
          context.strokeStyle = `hsla(${hue}, 90%, 55%, ${0.25 * alpha})`;
          context.lineWidth = 1;
          context.beginPath(); context.moveTo(a.x, a.y); context.lineTo(b.x, b.y); context.stroke();
        }
      }
    }

    // nodes
    for (let k = 0; k < nodes.length; k++) {
      const n = nodes[k];
  context.fillStyle = `hsla(${hue}, 90%, 45%, 0.9)`;
  context.beginPath(); context.arc(n.x, n.y, n.r, 0, Math.PI * 2); context.fill();
    }

    rafId = requestAnimationFrame(draw);
  }

  function onMove(e: MouseEvent) {
  const rect = c.getBoundingClientRect();
  mouse.x = e.clientX - rect.left; mouse.y = e.clientY - rect.top; mouse.active = true;
  }
  function onLeave() { mouse.active = false; }

  resize();
  window.addEventListener('resize', resize);
  c.addEventListener('mousemove', onMove);
  c.addEventListener('mouseleave', onLeave);
  rafId = requestAnimationFrame(draw);

  document.addEventListener('visibilitychange', () => {
    if (document.hidden) cancelAnimationFrame(rafId);
    else rafId = requestAnimationFrame(draw);
  });
}

// Hero entrance animation
document.addEventListener('DOMContentLoaded', () => {
  const title = document.getElementById('hero-title');
  const subtitle = document.getElementById('hero-subtitle');
  const cta = document.getElementById('hero-cta');
  const chips = document.querySelectorAll('.chip') as NodeListOf<HTMLElement>;
  const reduceMotion = window.matchMedia && window.matchMedia('(prefers-reduced-motion: reduce)').matches;
  
  // Set initial states
  if (title && !reduceMotion) {
    title.style.opacity = '0';
    title.style.transform = 'translateY(30px)';
  }

  if (subtitle && !reduceMotion) {
    subtitle.style.opacity = '0';
    subtitle.style.transform = 'translateY(20px)';
  }

  if (cta && !reduceMotion) {
    cta.style.opacity = '0';
    cta.style.transform = 'translateY(20px)';
  }
  
  // Set chips initial state
  chips.forEach((chip: HTMLElement) => {
    if (!reduceMotion) {
      chip.style.opacity = '0';
      chip.style.transform = 'scale(0.8) translateY(20px)';
    }
  });
  
  // Create entrance animation sequence (with reduced-motion fallback)
  if (!reduceMotion) {
    setTimeout(() => {
      animate(chips, { opacity: 1, transform: 'scale(1) translateY(0px)' }, { delay: stagger(0.1), duration: 0.8 });
    }, 0);
    setTimeout(() => { if (title) animate(title, { opacity: 1, transform: 'translateY(0px)' }, { duration: 0.8 }); }, 200);
    setTimeout(() => { if (subtitle) animate(subtitle, { opacity: 1, transform: 'translateY(0px)' }, { duration: 0.6 }); }, 500);
    setTimeout(() => { if (cta) animate(cta, { opacity: 1, transform: 'translateY(0px)' }, { duration: 0.6 }); }, 700);
  }
  
  // Chip hover animations
  chips.forEach((chip: HTMLElement) => {
    chip.addEventListener('mouseenter', () => {
      if (!reduceMotion) animate(chip, { transform: 'scale(1.05) translateY(-5px)' }, { duration: 0.3 });
    });
    chip.addEventListener('mouseleave', () => {
      if (!reduceMotion) animate(chip, { transform: 'scale(1) translateY(0px)' }, { duration: 0.3 });
    });
  });

  // Start canvas background
  initializeHeroCanvas();
});
</script>

<style>
/* Hero section styles (inlined from assets/css/hero.css to co-locate) */
.hero {
  position: relative;
  padding: 120px 0 100px;
  text-align: center;
  background-image: radial-gradient(1200px 600px at 50% -10%, #EAF2FF 0%, rgba(234,242,255,0) 60%),
                    linear-gradient(180deg, #FFFFFF 0%, #F7F9FC 100%);
  overflow: hidden;
}

/* Ensure hero text sits above animated layers */
.hero .container { position: relative; z-index: 2; }

/* Interactive hero objects */
.hero-objects { position: absolute; inset: 0; pointer-events: none; z-index: 1; }

.chip {
  position: absolute;
  width: 160px;
  height: 110px;
  border-radius: 16px;
  background: linear-gradient(135deg, rgba(11,95,255,0.12), rgba(15,181,181,0.12));
  border: 1px solid rgba(11,18,32,0.08);
  box-shadow: 0 12px 30px rgba(11,18,32,0.08);
  transform: translateZ(0);
  cursor: pointer;
  transition: filter 0.3s ease;
}
.chip:hover { filter: brightness(1.1); }
.chip::after { content: ''; position: absolute; inset: 0; border-radius: inherit; background: radial-gradient(circle at 70% 30%, rgba(255,255,255,0.35), rgba(255,255,255,0)); }
.chip-a { top: 18%; left: 8%; }
.chip-b { top: 62%; left: 14%; width: 120px; height: 84px; border-radius: 14px; }
.chip-c { top: 26%; right: 10%; }
.chip-d { bottom: 14%; right: 18%; width: 130px; height: 90px; border-radius: 14px; }

/* Dynamic shapes */
.hero::before,
.hero::after {
  content: '';
  position: absolute;
  top: -25%; left: -25%;
  width: 150%; height: 150%;
  pointer-events: none;
  z-index: 0;
}
.hero::before {
  background: radial-gradient(circle at 20% 30%, rgba(14, 95, 255, 0.15) 0%, rgba(14, 95, 255, 0) 60%),
              radial-gradient(circle at 80% 70%, rgba(15, 181, 181, 0.15) 0%, rgba(15, 181, 181, 0) 60%);
  /* Frozen background: no animation */
}
.hero::after {
  background: radial-gradient(circle at 75% 25%, rgba(255, 230, 250, 0.10) 0%, rgba(255, 230, 250, 0) 60%),
              radial-gradient(circle at 25% 80%, rgba(230, 245, 255, 0.10) 0%, rgba(230, 245, 255, 0) 60%);
  /* Frozen background: no animation */
}
@keyframes hero-move-1 { from { transform: translate(0%, 0%); } to { transform: translate(-30%, -20%); } }
@keyframes hero-move-2 { from { transform: translate(0%, 0%); } to { transform: translate(-20%, -30%); } }

/* Page-specific hero backgrounds */
.hero.about-hero {
  background-image: linear-gradient(to right, rgba(255,255,255,0.88), rgba(255,255,255,0.60)), url('/img/heroes/about_hero.png');
  background-size: cover;
  background-position: center;
}

.hero h1 {
  margin: 0;
  font-family: 'DM Sans', 'Inter', system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
  letter-spacing: -0.01em;
  font-size: clamp(2rem, 5.4vw, 3.25rem);
  color: var(--ink-900);
  line-height: 1.12;
}
.hero p { margin-top: 16px; font-size: 1.125rem; max-width: 700px; color: var(--ink-500); letter-spacing: 0.005em; margin-left:auto; margin-right:auto; }

/* Canvas backdrop under chips */
.hero-canvas { position: absolute; inset: 0; width: 100%; height: 100%; display: block; z-index: 0; }

.cta-row { margin-top: 32px; display: flex; flex-wrap: wrap; gap: 16px; justify-content: center; }

/* Mobile adjustments */
@media (max-width: 768px) {
  .chip { width: 120px; height: 80px; border-radius: 14px; }
  .chip-a { top: 14%; left: 4%; }
  .chip-b { top: 64%; left: 6%; }
  .chip-c { top: 22%; right: 6%; }
  .chip-d { bottom: 12%; right: 10%; }
  .hero h1 { font-size: clamp(1.6rem, 7vw, 2.2rem); }
  .hero { min-height: 100vh; padding: calc(96px + env(safe-area-inset-top, 0px)) 16px 64px 16px; display: flex; align-items: center; margin-left: auto; margin-right: auto; text-align: center; }
  .hero p { font-size: 1rem; }
  .cta-row { flex-direction: column; align-items: center; }
}

/* Respect reduced motion */
@media (prefers-reduced-motion: reduce) {
  .hero { animation: none; }
  .hero::before, .hero::after { animation: none; }
}
</style>
